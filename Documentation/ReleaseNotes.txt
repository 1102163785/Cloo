[0.8.0]
Cloo 0.8 is out! It took some time during which the OpenCL 1.1 functionality was integrated. This required some new types (ComputeUserEvent, ComputeSubBuffer) and a massive rewrite of the ComputeCommandQueue class which was fitted with more than 40 (!) new methods. These allow for safe and seamless data transitions between images, buffers and arrays (two and three dimensional too!) using both blocking and non-blocking calls. For example cooperation between buffers and arrays doesn't require a single GCHandle to be allocated on your part (yes, even on async calls). Everything is now handled internally.
ComputeEvents were improved too. They now expose .NET style events which fire upon command completition or abortion.
The supported OpenCL versions now include OpenCL 1.1. However, if you ignore the new features, Cloo can still fully cooperate with an OpenCL 1.0 only platform.
Documentation has been synced with the latest code and extended, where appropriate.

On the other hand such a number of changes had an impact on the existing interface. For this reason, 0.8 is NOT backward compatible. 

All ComputeCommandQueue methods require an ICollection<ComputeEventBase> typed argument instead of the previous ICollection<ComputeEvent>. Existing programs that make use of this argument need to be updated to the new collection type (a simple Find&Replace should be sufficient). These changes reflect the new type of events (user events) that was introduced in OpenCL 1.1. Because of this the code from the old ComputeEvent class was moved to a shared ComputeEventBase which is now a general event type. Specific functionality was implemented in the appropriate child classes (as in ComputeUserEvent.SetStatus). According to these modifications, ComputeEventListnow implements IList<ComputeEventBase> instead of IList<ComputeEvent>.

Most of the old ComputeCommandQueue methods were deprecated. The reasons behind the changes were increased security and bug prevention. Some examples:
1) Methods requiring arrays of a certain length had no way to enforce this. They were replaced by methods that take SysIntX2 and SysIntX3 arguments instead.
2) Because of the limitations of OpenCL 1.0, Cloo relied on the user to pin the data, issue a non-blocking call and then release the pin again. OpenCL 1.1 introduced a new event callback mechanism which allows Cloo to internally pin the necessary arguments and keep them out of the GC way until the execution of the non-blocking call has ended. Most of the new methods make use of this mechanism which is completely transparent for the application and considerably improves safety and ease of use. New users should not use code marked as obsolete. Existing users are strongly encouraged (but not enforced) to do the same thing.

Another changing class was the ComputeBuffer. OpenCL 1.1 introduced the concept of sub buffers (ComputeSubBuffer). For this reason the previous code of ComputeBuffer was moved into a new buffer root class (ComputeBufferBase). Fortunately, this change is backward compatible and no modifications to your program are required in this area.

Last but not least: Given the amount of changes in 0.8, I will continue to maintain the 0.7.x branch for those of you not willing to upgrade (either because it's too complicated or you just happen to like 0.7 more). Naturally, I will focus on the newer releases, so if you want me digging in older code you'll have to tell me (see readme.txt on how to do that). Also all the deprecated methods and properties will continue to be available accross the 0.8.x series.